multiply_with_hi_lo                                   mult ${1:\$s}, ${2:\$t}                                 LO=(($s * $t)&lt;&lt;32)&gt;&gt;32; HI=($s * $t)&gt;&gt;32;
divide_with_hi_lo                                     div ${1:\$s}, ${2:\$t}                                  LO=$s / $t; HI=$s % $t
multiply_unsigned_with_hi_lo                          multu ${1:\$s}, ${2:\$t}                                LO=(($s * $t)&lt;&lt;32)&gt;&gt;32; HI=($s * $t)&gt;&gt;32;
divide_unsigned_with_hi_lo                            divu ${1:\$s}, ${2:\$t}                                 LO=$s / $t; HI=$s % $t
shift_right_arithmetic_immediate                      sra ${1:\$d}, ${2:\$t}, ${3:shamt}                      shifts shamt number of bits
shift_right_arithmetic                                srav ${1:\$d}, ${2:\$t}, ${3:\$s}                       shifts $s number of bits
add_                                                  add ${1:\$d}, ${2:\$s}, ${3:\$t}                        $d = $s + $t
subtract_                                             sub ${1:\$d}, ${2:\$s}, ${3:\$t}                        $d = $s - $t
and_                                                  and ${1:\$d}, ${2:\$s}, ${3:\$t}                        $d = $s & $t
or_                                                   or ${1:\$d}, ${2:\$s}, ${3:\$t}                         $d = $s | $t
nor_                                                  nor ${1:\$d}, ${2:\$s}, ${3:\$t}                        $d = ~ ($s | $t)
jump_                                                 j ${1:Label}                                            PC = PC+4[31:28] . C*4
add_unsigned                                          addu ${1:\$d}, ${2:\$s}, ${3:\$t}                       $d = $s + $t
subtract_unsigned                                     subu ${1:\$d}, ${2:\$s}, ${3:\$t}                       $d = $s - $t
add_immediate                                         addi ${1:\$t}, ${2:\$s}, ${3:Label}                     $t = $s + C (signed)
add_immediate_unsigned                                addiu ${1:\$t}, ${2:\$s}, ${3:Label}                    $t = $s + C (unsigned)
load_word                                             lw ${1:\$t}, ${2:N}(${3:\$s})                           $t = Memory[$s + C]
load_halfword                                         lh ${1:\$t}, ${2:N}(${3:\$s})                           $t = Memory[$s + C] (signed)
load_halfword_unsigned                                lhu ${1:\$t}, ${2:N}(${3:\$s})                          $t = Memory[$s + C] (unsigned)
load_byte                                             lb ${1:\$t}, ${2:N}(${3:\$s})                           $t = Memory[$s + C] (signed)
load_byte_unsigned                                    lbu ${1:\$t}, ${2:N}(${3:\$s})                          $t = Memory[$s + C] (unsigned)
store_word                                            sw ${1:\$t}, ${2:N}(${3:\$s})                           Memory[$s + C] = $t
store_half                                            sh ${1:\$t}, ${2:N}(${3:\$s})                           Memory[$s + C] = $t
store_byte                                            sb ${1:\$t}, ${2:N}(${3:\$s})                           Memory[$s + C] = $t
load_upper_immediate                                  lui ${1:\$t}, ${2:Label}                                $t = C &lt;&lt; 16
move_from_high                                        mfhi ${1:\$d}                                           $d = HI
move_from_low                                         mflo ${1:\$d}                                           $d = LO
move_from_control_register                            mfcZ ${1:\$t}, ${2:\$d}                                 $t = Coprocessor[Z].ControlRegister[$d]
move_to_control_register                              mtcZ ${1:\$t}, ${2:\$d}                                 Coprocessor[Z].ControlRegister[$d] = $t
and_immediate                                         andi ${1:\$t}, ${2:\$s}, ${3:Label}                     $t = $s & C
or_immediate                                          ori ${1:\$t}, ${2:\$s}, ${3:Label}                      $t = $s | C
exclusive_or                                          xor ${1:\$d}, ${2:\$s}, ${3:\$t}                        $d = $s ^ $t
set_on_less_than                                      slt ${1:\$d}, ${2:\$s}, ${3:\$t}                        $d = ($s &lt; $t)
set_on_less_than_unsigned                             sltu ${1:\$d}, ${2:\$s}, ${3:\$t}                       $d = ($s &lt; $t)
set_on_less_than_immediate                            slti ${1:\$t}, ${2:\$s}, ${3:Label}                     $t = ($s &lt; C)
shift_left_logical_immediate                          sll ${1:\$d}, ${2:\$t}, ${3:shamt}                      $d = $t &lt;&lt; shamt
shift_right_logical_immediate                         srl ${1:\$d}, ${2:\$t}, ${3:shamt}                      $d = $t &gt;&gt; shamt
shift_left_logical                                    sllv ${1:\$d}, ${2:\$t}, ${3:\$s}                       $d = $t &lt;&lt; $s
shift_right_logical                                   srlv ${1:\$d}, ${2:\$t}, ${3:\$s}                       $d = $t &gt;&gt; $s
branch_on_equal                                       beq ${1:\$s}, ${2:\$t}, ${3:Label}                      if ($s == $t) go to PC+4+4*C
branch_on_not_equal                                   bne ${1:\$s}, ${2:\$t}, ${3:Label}                      if ($sÂ != $t) go to PC+4+4*C
jump_register                                         jr ${1:\$s}                                             goto address $s
jump_and_link                                         jal ${1:Label}                                          $31 = PC + 4; PC = PC+4[31:28] . C*4
move_                                                 move ${1:\$rt},${2:\$rs}                                add $rt,$rs,$zero
clear_                                                clear ${1:\$rt}                                         add $rt,$zero,$zero
not_                                                  not ${1:\$rt},${2:\$rs}                                 nor $rt,$rs,$zero
float_add_single                                      add.s ${1:\$x},${2:\$y},${3:\$z}                        $x = $y + $z
float_subtract_single                                 sub.s ${1:\$x},${2:\$y},${3:\$z}                        $x = $y - $z
float_multiply_single                                 mul.s ${1:\$x},${2:\$y},${3:\$z}                        $x = $y * $z
float_divide_single                                   div.s ${1:\$x},${2:\$y},${3:\$z}                        $x = $y / $z
float_add_double                                      add.d ${1:\$x},${2:\$y},${3:\$z}                        $x = $y + $z
float_subtract_double                                 sub.d ${1:\$x},${2:\$y},${3:\$z}                        $x = $y - $z
float_multiply_double                                 mul.d ${1:\$x},${2:\$y},${3:\$z}                        $x = $y * $z
float_divide_double                                   div.d ${1:\$x},${2:\$y},${3:\$z}                        $x = $y / $z
load_word_coprocessor                                 lwcZ ${1:\$x},${2:CONST(\$y)}                           Coprocessor[Z].DataRegister[$x] = Memory[$y + CONST]
store_word_coprocessor                                swcZ ${1:\$x},${2:CONST(\$y)}                           Memory[$y + CONST] = Coprocessor[Z].DataRegister[$x]
float_compare_single                                  c.lt.s ${1:\$f2},${2:\$f4}                              if ($f2 &lt; $f4) cond=1; else cond=0
float_compare_double                                  c.lt.d ${1:\$f2},${2:\$f4}                              if ($f2 &lt; $f4) cond=1; else cond=0
branch_on_float_true                                  bc1t ${1:100}                                           if (cond == 1) go to PC+4+100
branch_on_float_false                                 bc1f ${1:100}                                           if (cond == 0) go to PC+4+100
load_address                                          la ${1:\$rd},${2:LabelAddr}                             lui $rd,LabelAddr[31:16]; ori $rd,$rd,LabelAddr[15:0]
load_immediate                                        li ${1:\$rd},${2:IMMED}                                 lui $rd,IMMED[31:16]; ori $rd,$rd,IMMED[15:0]
branch_unconditionally                                b ${1:Label}                                            beq $zero,$zero,Label
branch_and_link                                       bal ${1:Label}                                          bgezal $zero,Label
branch_if_greater_than                                bgt ${1:\$rs},${2:\$rt},${3:Label}                      slt $at,$rt,$rs; bne $at,$zero,Label
branch_if_less_than                                   blt ${1:\$rs},${2:\$rt},${3:Label}                      slt $at,$rs,$rt; bne $at,$zero,Label
branch_if_greater_than_or_equal                       bge ${1:\$rs},${2:\$rt},${3:Label}                      slt $at,$rs,$rt; beq $at,$zero,Label
branch_if_less_than_or_equal                          ble ${1:\$rs},${2:\$rt},${3:Label}                      slt $at,$rt,$rs; beq $at,$zero,Label
branch_if_greater_than_unsigned                       bgtu ${1:\$rs},${2:\$rt},${3:Label}                     sltu $at,$rt,$rs; bne $at,$zero,Label
branch_if_greater_than_zero                           bgtz ${1:\$rs},${2:Label}                               slt $at,$zero,$rs; bne $at,$zero,Label
branch_if_equal_to_zero                               beqz ${1:\$rs},${2:Label}                               beq $rs,$zero,Label
multiply_                                             mul ${1:\$d},${2:\$s},${3:\$t}                          mult $s,$t; mflo $d
divides_and_returns_quotient                          div ${1:\$d},${2:\$s},${3:\$t}                          div $s,$t; mflo $d
divides_and_returns_remainder                         rem ${1:\$d},${2:\$s},${3:\$t}                          div $s,$t; mfhi $d